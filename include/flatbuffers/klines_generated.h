// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KLINES_MARKETDATA_H_
#define FLATBUFFERS_GENERATED_KLINES_MARKETDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace marketdata {

struct Kline;
struct KlineBuilder;

struct KlineList;
struct KlineListBuilder;

struct Kline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KlineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SYMBOL = 6,
    VT_OPEN_TIME = 8,
    VT_OPEN = 10,
    VT_HIGH = 12,
    VT_LOW = 14,
    VT_CLOSE = 16,
    VT_VOLUME = 18,
    VT_CLOSE_TIME = 20,
    VT_QUOTE_ASSET_VOLUME = 22,
    VT_TRADES_COUNT = 24,
    VT_TAKER_BUY_BASE_VOLUME = 26,
    VT_TAKER_BUY_QUOTE_VOLUME = 28
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t open_time() const {
    return GetField<uint64_t>(VT_OPEN_TIME, 0);
  }
  double open() const {
    return GetField<double>(VT_OPEN, 0.0);
  }
  double high() const {
    return GetField<double>(VT_HIGH, 0.0);
  }
  double low() const {
    return GetField<double>(VT_LOW, 0.0);
  }
  double close() const {
    return GetField<double>(VT_CLOSE, 0.0);
  }
  double volume() const {
    return GetField<double>(VT_VOLUME, 0.0);
  }
  uint64_t close_time() const {
    return GetField<uint64_t>(VT_CLOSE_TIME, 0);
  }
  double quote_asset_volume() const {
    return GetField<double>(VT_QUOTE_ASSET_VOLUME, 0.0);
  }
  int32_t trades_count() const {
    return GetField<int32_t>(VT_TRADES_COUNT, 0);
  }
  double taker_buy_base_volume() const {
    return GetField<double>(VT_TAKER_BUY_BASE_VOLUME, 0.0);
  }
  double taker_buy_quote_volume() const {
    return GetField<double>(VT_TAKER_BUY_QUOTE_VOLUME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_OPEN_TIME, 8) &&
           VerifyField<double>(verifier, VT_OPEN, 8) &&
           VerifyField<double>(verifier, VT_HIGH, 8) &&
           VerifyField<double>(verifier, VT_LOW, 8) &&
           VerifyField<double>(verifier, VT_CLOSE, 8) &&
           VerifyField<double>(verifier, VT_VOLUME, 8) &&
           VerifyField<uint64_t>(verifier, VT_CLOSE_TIME, 8) &&
           VerifyField<double>(verifier, VT_QUOTE_ASSET_VOLUME, 8) &&
           VerifyField<int32_t>(verifier, VT_TRADES_COUNT, 4) &&
           VerifyField<double>(verifier, VT_TAKER_BUY_BASE_VOLUME, 8) &&
           VerifyField<double>(verifier, VT_TAKER_BUY_QUOTE_VOLUME, 8) &&
           verifier.EndTable();
  }
};

struct KlineBuilder {
  typedef Kline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Kline::VT_ID, id, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(Kline::VT_SYMBOL, symbol);
  }
  void add_open_time(uint64_t open_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_OPEN_TIME, open_time, 0);
  }
  void add_open(double open) {
    fbb_.AddElement<double>(Kline::VT_OPEN, open, 0.0);
  }
  void add_high(double high) {
    fbb_.AddElement<double>(Kline::VT_HIGH, high, 0.0);
  }
  void add_low(double low) {
    fbb_.AddElement<double>(Kline::VT_LOW, low, 0.0);
  }
  void add_close(double close) {
    fbb_.AddElement<double>(Kline::VT_CLOSE, close, 0.0);
  }
  void add_volume(double volume) {
    fbb_.AddElement<double>(Kline::VT_VOLUME, volume, 0.0);
  }
  void add_close_time(uint64_t close_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_CLOSE_TIME, close_time, 0);
  }
  void add_quote_asset_volume(double quote_asset_volume) {
    fbb_.AddElement<double>(Kline::VT_QUOTE_ASSET_VOLUME, quote_asset_volume, 0.0);
  }
  void add_trades_count(int32_t trades_count) {
    fbb_.AddElement<int32_t>(Kline::VT_TRADES_COUNT, trades_count, 0);
  }
  void add_taker_buy_base_volume(double taker_buy_base_volume) {
    fbb_.AddElement<double>(Kline::VT_TAKER_BUY_BASE_VOLUME, taker_buy_base_volume, 0.0);
  }
  void add_taker_buy_quote_volume(double taker_buy_quote_volume) {
    fbb_.AddElement<double>(Kline::VT_TAKER_BUY_QUOTE_VOLUME, taker_buy_quote_volume, 0.0);
  }
  explicit KlineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Kline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Kline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Kline> CreateKline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    uint64_t open_time = 0,
    double open = 0.0,
    double high = 0.0,
    double low = 0.0,
    double close = 0.0,
    double volume = 0.0,
    uint64_t close_time = 0,
    double quote_asset_volume = 0.0,
    int32_t trades_count = 0,
    double taker_buy_base_volume = 0.0,
    double taker_buy_quote_volume = 0.0) {
  KlineBuilder builder_(_fbb);
  builder_.add_taker_buy_quote_volume(taker_buy_quote_volume);
  builder_.add_taker_buy_base_volume(taker_buy_base_volume);
  builder_.add_quote_asset_volume(quote_asset_volume);
  builder_.add_close_time(close_time);
  builder_.add_volume(volume);
  builder_.add_close(close);
  builder_.add_low(low);
  builder_.add_high(high);
  builder_.add_open(open);
  builder_.add_open_time(open_time);
  builder_.add_trades_count(trades_count);
  builder_.add_symbol(symbol);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Kline> CreateKlineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *symbol = nullptr,
    uint64_t open_time = 0,
    double open = 0.0,
    double high = 0.0,
    double low = 0.0,
    double close = 0.0,
    double volume = 0.0,
    uint64_t close_time = 0,
    double quote_asset_volume = 0.0,
    int32_t trades_count = 0,
    double taker_buy_base_volume = 0.0,
    double taker_buy_quote_volume = 0.0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return marketdata::CreateKline(
      _fbb,
      id,
      symbol__,
      open_time,
      open,
      high,
      low,
      close,
      volume,
      close_time,
      quote_asset_volume,
      trades_count,
      taker_buy_base_volume,
      taker_buy_quote_volume);
}

struct KlineList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KlineListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KLINES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<marketdata::Kline>> *klines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<marketdata::Kline>> *>(VT_KLINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KLINES) &&
           verifier.VerifyVector(klines()) &&
           verifier.VerifyVectorOfTables(klines()) &&
           verifier.EndTable();
  }
};

struct KlineListBuilder {
  typedef KlineList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_klines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<marketdata::Kline>>> klines) {
    fbb_.AddOffset(KlineList::VT_KLINES, klines);
  }
  explicit KlineListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KlineList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KlineList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KlineList> CreateKlineList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<marketdata::Kline>>> klines = 0) {
  KlineListBuilder builder_(_fbb);
  builder_.add_klines(klines);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KlineList> CreateKlineListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<marketdata::Kline>> *klines = nullptr) {
  auto klines__ = klines ? _fbb.CreateVector<::flatbuffers::Offset<marketdata::Kline>>(*klines) : 0;
  return marketdata::CreateKlineList(
      _fbb,
      klines__);
}

inline const marketdata::KlineList *GetKlineList(const void *buf) {
  return ::flatbuffers::GetRoot<marketdata::KlineList>(buf);
}

inline const marketdata::KlineList *GetSizePrefixedKlineList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<marketdata::KlineList>(buf);
}

inline bool VerifyKlineListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<marketdata::KlineList>(nullptr);
}

inline bool VerifySizePrefixedKlineListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<marketdata::KlineList>(nullptr);
}

inline void FinishKlineListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<marketdata::KlineList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedKlineListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<marketdata::KlineList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace marketdata

#endif  // FLATBUFFERS_GENERATED_KLINES_MARKETDATA_H_
